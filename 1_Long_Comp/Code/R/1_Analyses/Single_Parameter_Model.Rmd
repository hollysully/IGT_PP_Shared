---
title: "Single-Parameter Model"
output: html_document
---


# -------------------------------------------
# Setup
## Load Packages
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(rstan)
library(hBayesDM)
library(bayesplot)
library(here)
library(miscTools)
library(wBoot)
library(cmdstanr)
library(stringi)
library(ggpp)
library(lemon)
source(here("1_IGT_PP", "Code", "R", "3_other", "helpful_functions.R"))
library(MASS)
library(ggh4x)
library(grid)
```


## Create Task Data
```{r}
set.seed(20240611)
outcomes =
  data.frame(option_1 = sample(rep(c(0, 0, 0, 0, 0, 0, 0, 1, 1, 1), 10),
                               replace = F),
             option_2 = sample(rep(c(0, 0, 0, 1, 1, 1, 1, 1, 1, 1), 10),
                               replace = F))

write.csv(outcomes, here("1_Long_Comp", "Data", "outcomes.csv"))
summarise(outcomes, mean(option_1), mean(option_2))
```


## Functions
```{r, eval = T}
#------------------------------------------------------------------------------
# USE SOFTMAX TO OBTAIN CHOICE PROBABILITIES - USED IN SIMULATIONS
softmax = function(values){
  return(exp(values) / sum(exp(values)))
}


#------------------------------------------------------------------------------
# SIMULATION FUNCTION
simulate_RL = function(learning_rate = .5, N = 100, n_trials = 100,
                       Sr_probs = c(.3, .7),
                       custom_seed = 20240709, label = "") {
  set.seed(seed = custom_seed)
  A = learning_rate
  utility = rep(0,2)
  data = data.frame(sim = label,
                    A = A,
                    trial = 0,
                    prob_1 = .5,
                    prob_2 = .5,
                    utility_1 = 0,
                    utility_2 = 0,
                    outcome = NA,
                    choice = NA)
    
  for(t in 1:n_trials){
    prob = softmax(c(utility[1], utility[2]))
    
    choice = sample(c(1,2), 1, prob = prob)
    
    outcome = rbinom(1, 1, Sr_probs[choice])
  
    utility[choice] = utility[choice] + A * (outcome - utility[choice])
    
    data = data.frame(sim = label,
                      A = A,
                      trial = t,
                      prob_1 = prob[1],
                      prob_2 = prob[2],
                      utility_1 = utility[1],
                      utility_2 = utility[2],
                      outcome = outcome,
                      choice = choice) %>% 
      bind_rows(data)
  }
  data %>%
    return()
}
```


## Test Functions
```{r}
sim_data = bind_rows(simulate_RL(learning_rate = .2, N = 1, label = "hi"),
                     simulate_RL(learning_rate = .05, N = 1, label = "lo")) %>% 
  pivot_longer(ends_with(c("1", "2")), names_to = "variable", values_to = "value") %>% 
  separate("variable", into = c("variable", "option")) %>% 
  pivot_wider(names_from = "variable", values_from = "value")
```


### Compare Options B/w Simulations
```{r}
ggplot(sim_data, aes(x = trial, y = utility, color = option)) +
  geom_point() +
  geom_line() +
  scale_y_continuous(limits = c(0, 1)) +
  theme_classic() +
  facet_rep_grid(.~sim)


ggplot(sim_data, aes(x = trial, y = prob, color = option)) +
  geom_point() +
  geom_line() +
  scale_y_continuous(limits = c(0, 1)) +
  theme_classic() +
  facet_rep_grid(.~sim)
```


### Compare Simulations B/w Options
```{r}
ggplot(sim_data, aes(x = trial, y = utility, color = sim)) +
  geom_point() +
  geom_line() +
  scale_y_continuous(limits = c(0, 1)) +
  theme_classic() +
  facet_rep_grid(.~option)


ggplot(sim_data, aes(x = trial, y = prob, color = sim)) +
  geom_point() +
  geom_line() +
  scale_y_continuous(limits = c(0, 1)) +
  theme_classic() +
  facet_rep_grid(.~option)
```


# -------------------------------------------
# Simulate Parameters
## Setup
```{r, eval = T}
# setup for how much data will be generated - i.e., n_sessions x N = # of observations
n_sessions = 5 # number of sessions
N = 100        # number of participants


# group-level parameters
mu_intercept_UT = qnorm(.1) # mean untransformed intercept for learning rate
sd_intercept_UT = 1         # standard deviation of intercepts

sd_beta_UT = 1                       # standard deviation of intercepts
effect_size = .5                     # Cohen's d for slope effect
mu_beta_UT = effect_size*sd_beta_UT  # slope effect for session - not sure if the multiplication by sd_beta_UT is correct, but if it's 1, then it works out for now
```


## Method 1: Centered Parameterizattion
```{r, eval = T}
set.seed(20240611)

# setup for building variance-covariance matrix
int_slope_R = .5 # correlation between intercepts and slopes
R = matrix(data = c(1, int_slope_R, int_slope_R, 1), nrow = 2, ncol = 2) # correlation matrix
SD = matrix(data = c(sd_intercept_UT, 0, 0, sd_beta_UT), nrow = 2, ncol = 2) # SD matrix
VC = SD%*%R%*%SD # variance-covariance matrix

# simulate person-level intercept & slope parameters
parameters = mvrnorm(N, mu = c(mu_intercept_UT, mu_beta_UT), Sigma = VC) # draw from MVT Normal

# combine the parameters into the As
A_UTs = parameters[,1] + parameters[,2]%*%t(1:n_sessions)

# plot untransformed As
plot(rep(1:n_sessions, N), A_UTs)
points(1:n_sessions, apply(A_UTs, 2, mean),
       pch = 15, col = "red", cex = 1.5)

# plot transformed As
plot(rep(1:n_sessions, N), pnorm(A_UTs))
points(1:n_sessions, pnorm(apply(A_UTs, 2, mean)),
       pch = 15, col = "red", cex = 1.5)

# run MLM to see if it captures changes across time
data.frame(ID = 1:N, session = A_UTs) %>%
  pivot_longer(starts_with("session"), names_to = "session", values_to = "A_UT",
               names_prefix = "session.", names_transform = list(session = as.numeric)) %>%
  mutate(A = pnorm(A_UT)) %>%
  lme4::lmer(A_UT ~ session + (session|ID), data = .) %>%
  # summary()
  car::Anova(type = "III")
```


## Method 2: Non-Centered Parameterization
```{r, eval = T}
set.seed(20240611)

# setup for building variance-covariance matrix
int_slope_R = .5 # correlation between intercepts and slopes
R = matrix(data = c(1, int_slope_R, int_slope_R, 1), nrow = 2, ncol = 2) # correlation matrix
SD = matrix(data = c(1, 0, 0, 1), nrow = 2, ncol = 2) # SD matrix
VC = SD%*%R%*%SD # variance-covariance matrix

# simulate person-level deviations from the group-level intercept & slope parameters
int_slope_deviations = mvrnorm(N, c(0, 0), Sigma = VC) # draw from MVT Normal

# add person-level deviations to intercepts and slopes
parameters = matrix(data = NA, nrow = N, ncol = 2)
parameters[,1] = mu_intercept_UT +  int_slope_deviations[,1] * sd_intercept_UT # intercepts
parameters[,2] = mu_beta_UT + int_slope_deviations[,2] * sd_beta_UT            # slopes

# combine the parameters into the As
A_UTs = parameters[,1] + parameters[,2]%*%t(1:n_sessions) # generate session-specific untransformed As

# plot untransformed As
plot(rep(1:n_sessions, N), A_UTs)
points(1:n_sessions, apply(A_UTs, 2, mean),
       pch = 15, col = "red", cex = 1.5)

# plot transformed As
plot(rep(1:n_sessions, N), pnorm(A_UTs))
points(1:n_sessions, pnorm(apply(A_UTs, 2, mean)),
       pch = 15, col = "red", cex = 1.5)

# run MLM to see if it captures changes across time
data.frame(ID = 1:N, session = A_UTs) %>%
  pivot_longer(starts_with("session"), names_to = "session", values_to = "A_UT",
               names_prefix = "session.", names_transform = list(session = as.numeric)) %>%
  mutate(A = pnorm(A_UT)) %>%
  lme4::lmer(A_UT ~ session + (session|ID), data = .) %>%
  # summary()
  car::Anova(type = "III")
```


```{r}

```


# -------------------------------------------







